<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Matrix Drone Defense - GAME MODE</title>
<style>
html, body { margin: 0; height: 100%; background: black; overflow: hidden; cursor: none; }
canvas { display: block; }
#hud {
  position: absolute;
  top: 10px;
  left: 10px;
  color: #00ffcc;
  font-family: monospace;
  font-size: 18px;
  z-index: 10;
}
</style>
</head>
<body>
<div id="hud">Score: 0 | Lives: 3</div>
<script>
'use strict';

const canvas = document.createElement("canvas");
const ctx = canvas.getContext("2d");
document.body.appendChild(canvas);
const hud = document.getElementById('hud');

let cw, ch;
const resize = () => { cw = canvas.width = window.innerWidth; ch = canvas.height = window.innerHeight; };
window.addEventListener("resize", resize);
resize();

const matrixChars = '01';
let drones = [], totalDrones = 120;
let mouse = { x: cw/2, y: ch/2, inside: true };
let score = 0, lives = 3, gameOver = false, magnetActive = false;

// Player triangle
const player = { x: cw/2, y: ch - 60, w: 36, h: 22, speed: 8 };

// Shooting
const bullets = [];
const BULLET_SPEED = 12;
let canShoot = true;
const SHOOT_COOLDOWN = 120;

// Difficulty
let speedMultiplier = 0.18;
const SPEED_INCREMENT = 0.03;
const MAX_SPEED = 10;

// Key states
const keys = {};
window.addEventListener('keydown', e => { 
  keys[e.code] = true; 
  if(e.key.toLowerCase() === 'm') magnetActive = true; 
  if(e.key.toLowerCase() === 'r' && gameOver) restart(); 
});
window.addEventListener('keyup', e => { 
  keys[e.code] = false; 
  if(e.key.toLowerCase() === 'm') magnetActive = false; 
});

// Mouse
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; mouse.inside = true; });
window.addEventListener('mouseleave', () => mouse.inside = false);

function shoot(){
  if(gameOver || !canShoot) return;
  bullets.push({ x: player.x, y: player.y - player.h - 6 });
  canShoot = false;
  setTimeout(()=>canShoot=true, SHOOT_COOLDOWN);
}

function resetDrone(d, init=false){
  d.x = Math.random()*cw;
  d.y = Math.random()*(ch*0.35)-ch*0.2;
  d.size = 18 + Math.random()*12;
  d.char = matrixChars[Math.floor(Math.random()*matrixChars.length)];
  d.flipTimer = Math.random()*120;
  d.vx = (Math.random()-0.5)*0.6;
  d.vy = (Math.random()-0.5)*0.6;
  if(init){ d.x = cw/2 + (Math.random()-0.5)*cw*0.6; d.y = ch*0.15 + Math.random()*ch*0.2; }
}

for(let i=0;i<totalDrones;i++){ let d = {}; resetDrone(d,true); drones.push(d); }

function drawPlayer(){
  ctx.strokeStyle = 'rgba(0,255,255,0.9)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(player.x, player.y - player.h/1.2);
  ctx.lineTo(player.x - player.w/2, player.y + player.h/1.5);
  ctx.lineTo(player.x + player.w/2, player.y + player.h/1.5);
  ctx.closePath();
  ctx.stroke();
}

function drawCrosshair(){
  if(!mouse.inside) return;
  ctx.strokeStyle='#00ffcc';
  ctx.lineWidth=1.5;
  ctx.beginPath();
  ctx.moveTo(mouse.x-12, mouse.y); ctx.lineTo(mouse.x+12, mouse.y);
  ctx.moveTo(mouse.x, mouse.y-12); ctx.lineTo(mouse.x, mouse.y+12);
  ctx.stroke();
}

function drawHUD(){ hud.textContent=`Score: ${score} | Lives: ${lives}`; }

function restart(){ 
  score=0; lives=3; gameOver=false; speedMultiplier=0.18; bullets.length=0; 
  drones.forEach(d=>resetDrone(d,true)); 
}

function drawGameOver(){
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,cw,ch);
  ctx.fillStyle='#ff4444'; ctx.font='48px monospace'; ctx.textAlign='center'; ctx.fillText('GAME OVER',cw/2,ch/2-20);
  ctx.fillStyle='#00ffcc'; ctx.font='24px monospace'; ctx.fillText(`Score: ${score}`,cw/2,ch/2+20);
  ctx.font='16px monospace'; ctx.fillText(`Press R to restart`,cw/2,ch/2+58);
}

function updateAndDrawDrones(delta){
  for(let d of drones){
    d.flipTimer-=delta;
    if(d.flipTimer<=0){ d.char = matrixChars[Math.floor(Math.random()*matrixChars.length)]; d.flipTimer=30+Math.random()*160; }

    const size = d.size;
    ctx.font=`${size}px monospace`;
    ctx.fillStyle=`rgba(64,224,208,${0.6+Math.random()*0.35})`;
    ctx.fillText(d.char,d.x,d.y);

    d.vx += (Math.sin(Date.now()*0.001 + d.x)*0.002);
    d.vy += (Math.cos(Date.now()*0.001 + d.y)*0.002);

    const dx = (magnetActive && mouse.inside ? mouse.x : player.x) - d.x;
    const dy = (magnetActive && mouse.inside ? mouse.y : player.y) - d.y;
    const dist = Math.hypot(dx,dy)||1;
    d.vx += dx/dist*0.02*(1+speedMultiplier);
    d.vy += dy/dist*0.02*(1+speedMultiplier);

    d.x += d.vx;
    d.y += d.vy;
    d.vx*=0.93; d.vy*=0.93;

    // Bullet collision
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      const distB=Math.hypot(b.x-d.x,b.y-d.y);
      if(distB<Math.max(12,size*0.6)){
        bullets.splice(i,1);
        score++;
        resetDrone(d);
        break;
      }
    }

    // Player collision
    const distP = Math.hypot(d.x - player.x, d.y - (player.y - player.h/4));
    if(distP<18){ lives--; if(lives<=0) gameOver=true; resetDrone(d); }

    if(d.x<-50 || d.x>cw+50 || d.y<-50 || d.y>ch+50) resetDrone(d);
  }
}

function handlePlayerMovement(){
  if(keys['ArrowLeft']) player.x -= player.speed;
  if(keys['ArrowRight']) player.x += player.speed;
  if(keys['ArrowUp']) player.y -= player.speed;
  if(keys['ArrowDown']) player.y += player.speed;
  if(keys['Space']) shoot(); // Spacebar shoots
  // Keep player in bounds
  player.x = Math.max(0, Math.min(cw, player.x));
  player.y = Math.max(0, Math.min(ch, player.y));
}

// Main loop
let lastTime = performance.now();
function loop(now){
  const delta = now-lastTime; lastTime=now;
  ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(0,0,cw,ch);

  if(gameOver){ drawGameOver(); drawHUD(); requestAnimationFrame(loop); return; }

  handlePlayerMovement();

  bullets.forEach((b,i)=>{ 
    b.y-=BULLET_SPEED; 
    ctx.fillStyle='rgba(0,255,255,0.95)'; 
    ctx.fillRect(b.x-1,b.y,2,10); 
    if(b.y<-20) bullets.splice(i,1); 
  });

  updateAndDrawDrones(delta);
  drawPlayer(); 
  drawCrosshair();
  drawHUD();

  // Hyper fast auto ramp-up
  speedMultiplier += SPEED_INCREMENT;
  if(speedMultiplier > MAX_SPEED) speedMultiplier = MAX_SPEED;

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
